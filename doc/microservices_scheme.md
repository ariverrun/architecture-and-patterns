# Схема микросервисов

В системе существуют следующие микросервисы:

1. **User**. Сервис отвечающий за пользователей, здесь они регистрируются, здесь хранится вся информация о них.

2. **Auth**. Сервис авторизации и аутентификации. Через него происходит аутентификация пользователя в системе, здесь выдаются токены доступа и права на различные действия.

3. **Game**. Игровой сервис, в котором происходит непосредственно игра.

4. **Tournament**. Сервис турниров.

5. **Claim**. Сервис заявок на турнир либо на внетурнирную игру.

6. **Invite**. Сервис приглашений на турнир.

7. **Matching**. Сервис подбора игроков на игру. Обрабатывая заявки он подбирает пользователей которые примут участие в игре.

8. **Rating**. Сервис рейтинга. Он обсчитывает результаты игроков и присваивает им очки.

9. **Notification**. Сервис уведомлений.

Ниже на диаграммах представлены взаимодействия вышеперечисленных сервисов в рамках различных процессов. Пунктирными стрелками показанно асинхронное взаимодействие через брокер сообщений, цельными - синхронное через HTTP протокол.

1. **Регистрация пользователя, аутентификация и авторизация**

![Регистрация пользователя, аутентификация и авторизация](https://raw.githubusercontent.com/ariverrun/architecture-and-patterns/21-microservice-creation/doc/image/reg-and-auth.drawio.png "Регистрация пользователя, аутентификация и авторизация")

Сервис авторизации использует данные из сервиса пользователей для того, чтобы сверить доступы и определить права. Далее он выдает JWT токены, которые соодержат в себе основную информацию необходимую другим сервисам для взаимодействия с пользователем.

2. **Организация турнира**

![Организация турнира](https://raw.githubusercontent.com/ariverrun/architecture-and-patterns/21-microservice-creation/doc/image/tournament-org.drawio.png "Организация турнира")

3. **Подбор игроков и игра**

![Подбор игроков и игра](https://raw.githubusercontent.com/ariverrun/architecture-and-patterns/21-microservice-creation/doc/image/match-and-game.drawio.png "Подбор игроков и игра")

Отправка игровых событий от игрового сервера клиенту происходит по протоколу UDP, так как здесь более важна скорость, а потеря отдельных пакетов может быть не критичной.

4. **Присвоение рейтинга**

![Присвоение рейтинга](https://raw.githubusercontent.com/ariverrun/architecture-and-patterns/21-microservice-creation/doc/image/rating.drawio.png "Присвоение рейтинга")

Наибольшие проблемы с масштабированием потенциально могут иметь сервисы Game, Claim и Matching. Здесь предполагается самая высокая нагрузка, при этом здесь важен наименьший latency. В игре не должно быть задержек, подбор игроков также должен осуществляться быстро. В то время как рассчет рейтинга и рассылка уведомлений к задержкам терпимы. Проще всего из этих 3 сервисов масштабируется Game, можно просто добавить новые инстансы сервиса и зарегистрировать их в Service Registry. Каждый инстанс имеет свою БД, которая в основном используется для хранения записей истории игр (сериализованная последовательность комманд). Тот же принцип применим к сервису Matching, который просто аггрегирует данные, получаемые от других сервисов и долго их не хранит. Но с мастштабированием сервиса Claim есть другая проблема, которая также затронет и сервис Matching. Если мы добавляем новые экземпляры сервиса, здесь важно определиться по какому принципу будет работать марштрутизация при создании новых заявок. И как должен работать сервис Matching с несколькими экземплярами сервиса заявок, должен ли он обходить их все или нет. Возможно будет удачным решением использовать географическую маршрутизацию заявок, если игроки разбросаны по миру. Если мы в целом и подбираем игроков из одного региона в одну игру то это будет максимально эффективно, но если нет, то это не очень подойдет и возможно маршрутизировать лучше по принципу round-robin или случайным образом или по степени загрузки.

Меняться требования чаще всего будут к сервисам Game (так как будут возникать новые игровые функции), Matching (сейчас не очень понятен принцип подбора игроков) и Rating (вероятно что здесь будут сложные схемы присвоения очков, которые будут строиться в том числе на анализе игровых событий например количество сбитых кораблей и т.п.). Во многом здесь можно использовать одни и те же принципы, а именно выделение абстракций, зависимости от интерфейсов, инверсия зависимостей, инъекции зависимостей, управление зависимостями путем настройки конфигурации, использование IoC. Также следует подумать над системой игровых событий, которая могла бы использоваться как для построения рейтинга (с минимальными изменениями существующего кода, только при помощи добавления новых обработчик событий), так и для других целей, например различных уведомлений по ним. Такие события могут возникать в игре, аггрегироваться и по окончании сохраняться как и история, а сервис Rating при рассчете баллов сходит по АПИ за ними и возьмет то что ему нужно.

