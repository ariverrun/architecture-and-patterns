<?php

declare(strict_types=1);

namespace App\AutoGeneration;

use App\AutoGeneration\Exception\IsNotInterfaceExeption;
use App\AutoGeneration\Exception\MethodsConflictException;
use App\DependencyInjection\IoC;
use App\DependencyInjection\IocInterface;
use App\GameObject\ObjectWithPropertiesContainerInterface;
use InvalidArgumentException;
use ReflectionClass;
use ReflectionMethod;
use ReflectionParameter;

class AdapterClassMaker
{
    private const CLASSES_NAME_PREFIX = 'AutoGenerated_';
    private const NAMESPACE_SEPARATOR_REPLACER = '_';
    private const INTERFACES_NAME_SEPARATOR = '_And_';
    private const CLASSES_NAME_SUFFIX = '_Adapter';

    public function __construct(
        private readonly string $iocClass = IoC::class,
    ) {
        if (!isset(class_implements($iocClass)[IocInterface::class])) {
            throw new InvalidArgumentException($iocClass . ' does not implement ' . IocInterface::class);
        }
    }

    public function makeAdapterClass(string ...$interfacesToImplement): string
    {
        $className = $this->buildClassName($interfacesToImplement);

        if (class_exists($className)) {
            return $className;
        }

        $interfacesReflectors = $this->buildInterfacesReflectors($interfacesToImplement);

        $this->checkThatArgsAreInterfaces($interfacesReflectors);

        $this->checkMethodsConflicts($interfacesReflectors);

        list($classDescriptionStart, $classDescriptionEnd) = $this->buildClassPrimeDescriptionParts($className, $interfacesToImplement);

        $constructorDescription = $this->buildConstructorDescription();

        $methodsDescriptions = $this->buildMethodsDesciptions($interfacesReflectors);

        $classDescription = $classDescriptionStart .
                            $constructorDescription;

        foreach ($methodsDescriptions as $methodDescription) {
            $classDescription .= $methodDescription;
        }

        $classDescription .= $classDescriptionEnd;

        eval($classDescription);

        return $className;
    }

    /**
     * @param string[] $interfacesToImplement
     */
    private function buildClassName(array $interfacesToImplement): string
    {
        sort($interfacesToImplement);

        return self::CLASSES_NAME_PREFIX . implode(self::INTERFACES_NAME_SEPARATOR, array_map(function (string $interfaceName): string {
            return str_replace('\\', self::NAMESPACE_SEPARATOR_REPLACER, $interfaceName);
        }, $interfacesToImplement)) . self::CLASSES_NAME_SUFFIX;
    }

    /**
     * @param string[] $interfacesToImplement
     *
     * @return array{0: string, 1: string}
     */
    private function buildClassPrimeDescriptionParts(string $className, array $interfacesToImplement): array
    {
        $classDescriptionStart = '
            class ' . $className . ' implements ' . implode(', ', $interfacesToImplement) . '
            {
        ';

        $classDescriptionEnd = '
            }
        ';

        return [$classDescriptionStart, $classDescriptionEnd];
    }

    private function buildConstructorDescription(): string
    {
        return '
            public function __construct(
                private readonly ' . ObjectWithPropertiesContainerInterface::class . ' $adaptee,
            ) {
            }        
        ';
    }

    /**
     * @param string[] $interfaces
     *
     * @return ReflectionClass[]
     */
    private function buildInterfacesReflectors(array $interfaces): array
    {
        return array_map(static function (string $interface): ReflectionClass {
            return new ReflectionClass($interface);
        }, $interfaces);
    }

    /**
     * @param ReflectionClass[] $reflectors
     *
     * @throws IsNotInterfaceExeption
     */
    private function checkThatArgsAreInterfaces(array $reflectors): void
    {
        foreach ($reflectors as $reflector) {
            if (false === $reflector->isInterface()) {
                throw new IsNotInterfaceExeption(
                    $reflector->getName() . ' is not an interface'
                );
            }
        }
    }

    /**
     * @param ReflectionClass[] $reflectors
     *
     * @throws MethodsConflictException
     */
    private function checkMethodsConflicts(array $reflectors): void
    {
        $allRequiredMethods = [];

        foreach ($reflectors as $reflector) {
            $methods = $reflector->getMethods();

            foreach ($methods as $method) {
                $methodName = $method->getName();

                if (array_key_exists($methodName, $allRequiredMethods)) {
                    throw new MethodsConflictException(
                        'Both interfaces ' .
                        $allRequiredMethods[$methodName] .
                        ' and ' . $reflector->getName() .
                        ' require ' . $methodName .
                        ' method implementation'
                    );
                }

                $allRequiredMethods[$methodName] = $reflector->getName();
            }
        }
    }

    /**
     * @param ReflectionClass[] $reflectors
     *
     * @return string[]
     */
    private function buildMethodsDesciptions(array $reflectors): array
    {
        $methodsDescriptions = [];

        foreach ($reflectors as $reflector) {
            $methods = $reflector->getMethods();

            foreach ($methods as $method) {
                if ($method->isPublic()) {
                    $parametersDescription = $this->buildMethodParametersDescription($method);

                    $methodDescriprionStart = '
                        public function ' . $method->getName() . '(' . $parametersDescription . '): ' . $method->getReturnType() . '
                    ';

                    $methodBodyDescription = null;

                    $parametersList = !empty($method->getParameters()) ? ', ' . implode(',', array_map(function (ReflectionParameter $reflectionParameter): string {
                        return '$' . $reflectionParameter->getName();
                    }, $method->getParameters())) : '';

                    if ($this->isMethodSetter($method)) {

                        $methodBodyDescription = $this->iocClass .
                            '::resolve("Spaceship.Operations.' . $reflector->getName() . '.' .
                            preg_replace('/set/', '', $method->getName(), 1) .
                            '.set' .
                        '", $this->adaptee' .
                        $parametersList .
                        ')->execute();';

                    } elseif ($this->isMethodGetter($method)) {
                        $methodBodyDescription = 'return ' . $this->iocClass .
                            '::resolve("Spaceship.Operations.' . $reflector->getName() . '.' .
                            preg_replace('/get/', '', $method->getName(), 1) .
                            '.get' .
                        '", $this->adaptee);';
                    } else {
                        $methodBodyDescription = ((string)$method->getReturnType() !== 'void' ? 'return ' : '') .
                            $this->iocClass .
                            '::resolve("Spaceship.Operations.' . $reflector->getName() . '.' .
                            $method->getName() .
                        '", $this->adaptee' .
                        $parametersList .
                        ')->execute();';
                    }

                    $methodBodyDescription = $methodDescriprionStart .
                    '{
                        ' . $methodBodyDescription . '
                    }';

                    $methodsDescriptions[] = $methodBodyDescription;

                }
            }
        }

        return $methodsDescriptions;
    }

    private function buildMethodParametersDescription(ReflectionMethod $reflectionMethod): string
    {
        $parametersDescriptionParts = [];

        foreach ($reflectionMethod->getParameters() as $parameter) {
            $parametersDescriptionParts[] = $parameter->getType()->getName() . ' $' . $parameter->getName();
        }

        return implode(', ', $parametersDescriptionParts);
    }

    private function isMethodSetter(ReflectionMethod $reflectionMethod): bool
    {
        return str_starts_with($reflectionMethod->getName(), 'set');
    }

    private function isMethodGetter(ReflectionMethod $reflectionMethod): bool
    {
        return str_starts_with($reflectionMethod->getName(), 'get');
    }
}
